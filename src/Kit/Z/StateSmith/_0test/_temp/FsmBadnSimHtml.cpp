// Autogenerated with StateSmith 0.19.0+b5719011215d41a81572ed347c02b22db5d1a48f.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "FsmBadnSimHtml.hpp"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset


// Starts the state machine. Must be called before dispatching events. Not thread safe.
void FsmBadnSimHtml::start()
{
    ROOT_enter();
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: / { ActionA(); } TransitionTo(State1)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `ActionA();`.
            ActionA();
            
            // Step 3: Enter/move towards transition target `State1`.
            STATE1_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `eventId` parameter is valid.
void FsmBadnSimHtml::dispatchEvent(EventId eventId)
{
    switch (this->stateId)
    {
        // STATE: FsmBadnSimHtml
        case StateId::ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: State1
        case StateId::STATE1:
            switch (eventId)
            {
                case EventId::EVENT1: STATE1_event1(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State2
        case StateId::STATE2:
            switch (eventId)
            {
                case EventId::DO: STATE2_do(); break;
                case EventId::EVENT3: STATE2_event3(); break;
                case EventId::EVENT2: STATE2_event2(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State3
        case StateId::STATE3:
            switch (eventId)
            {
                case EventId::EVENT3: STATE3_event3(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State3A
        case StateId::STATE3A:
            switch (eventId)
            {
                case EventId::EVENT1: STATE3A_event1(); break;
                case EventId::EVENT3: STATE3_event3(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State3B
        case StateId::STATE3B:
            switch (eventId)
            {
                case EventId::EVENT2: STATE3B_event2(); break;
                case EventId::EVENT3: STATE3_event3(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: TERMINAL
        case StateId::TERMINAL:
            // No events handled by this state (or its ancestors).
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
void FsmBadnSimHtml::exitUpToStateHandler(StateId desiredState)
{
    while (this->stateId != desiredState)
    {
        switch (this->stateId)
        {
            case StateId::STATE1: STATE1_exit(); break;
            
            case StateId::STATE2: STATE2_exit(); break;
            
            case StateId::STATE3: STATE3_exit(); break;
            
            case StateId::STATE3A: STATE3A_exit(); break;
            
            case StateId::STATE3B: STATE3B_exit(); break;
            
            case StateId::TERMINAL: TERMINAL_exit(); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

void FsmBadnSimHtml::ROOT_enter()
{
    this->stateId = StateId::ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE1
////////////////////////////////////////////////////////////////////////////////

void FsmBadnSimHtml::STATE1_enter()
{
    this->stateId = StateId::STATE1;
}

void FsmBadnSimHtml::STATE1_exit()
{
    this->stateId = StateId::ROOT;
}

void FsmBadnSimHtml::STATE1_event1()
{
    // State1 behavior
    // uml: Event1 TransitionTo(ROOT.<ChoicePoint>(c1))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        STATE1_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(c1)`.
        // ROOT.<ChoicePoint>(c1) is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<ChoicePoint>(c1) behavior
        // uml: [guard1()] / { ActionB(); } TransitionTo(State2)
        if (guard1())
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `ActionB();`.
            ActionB();
            
            // Step 3: Enter/move towards transition target `State2`.
            STATE2_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<ChoicePoint>(c1)
        
        // ROOT.<ChoicePoint>(c1) behavior
        // uml: else / { ActionC(); } TransitionTo(State3)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `ActionC();`.
            ActionC();
            
            // Step 3: Enter/move towards transition target `State3`.
            STATE3_enter();
            
            // Finish transition by calling pseudo state transition function.
            State3_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<ChoicePoint>(c1)
    } // end of behavior for State1
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE2
////////////////////////////////////////////////////////////////////////////////

void FsmBadnSimHtml::STATE2_enter()
{
    this->stateId = StateId::STATE2;
    
    // State2 behavior
    // uml: enter / { ActionH();\nActionB(); }
    {
        // Step 1: execute action `ActionH();\nActionB();`
        ActionH();
        ActionB();
    } // end of behavior for State2
}

void FsmBadnSimHtml::STATE2_exit()
{
    this->stateId = StateId::ROOT;
}

void FsmBadnSimHtml::STATE2_do()
{
    // State2 behavior
    // uml: do / { ActionF(); }
    {
        // Step 1: execute action `ActionF();`
        ActionF();
    } // end of behavior for State2
    
    // No ancestor handles this event.
}

void FsmBadnSimHtml::STATE2_event2()
{
    // State2 behavior
    // uml: Event2 TransitionTo(State3)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        STATE2_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State3`.
        STATE3_enter();
        
        // Finish transition by calling pseudo state transition function.
        State3_InitialState_transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State2
    
    // No ancestor handles this event.
}

void FsmBadnSimHtml::STATE2_event3()
{
    // State2 behavior
    // uml: Event3 TransitionTo(TERMINAL)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        STATE2_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `TERMINAL`.
        TERMINAL_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State2
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE3
////////////////////////////////////////////////////////////////////////////////

void FsmBadnSimHtml::STATE3_enter()
{
    this->stateId = StateId::STATE3;
    
    // State3 behavior
    // uml: enter / { ActionG(); }
    {
        // Step 1: execute action `ActionG();`
        ActionG();
    } // end of behavior for State3
}

void FsmBadnSimHtml::STATE3_exit()
{
    this->stateId = StateId::ROOT;
}

void FsmBadnSimHtml::STATE3_event3()
{
    // State3 behavior
    // uml: Event3 / { ActionA(); } TransitionTo(State1)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: `ActionA();`.
        ActionA();
        
        // Step 3: Enter/move towards transition target `State1`.
        STATE1_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State3
    
    // No ancestor handles this event.
}

void FsmBadnSimHtml::State3_InitialState_transition()
{
    // State3.<InitialState> behavior
    // uml: TransitionTo(State3A)
    {
        // Step 1: Exit states until we reach `State3` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State3A`.
        STATE3A_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State3.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE3A
////////////////////////////////////////////////////////////////////////////////

void FsmBadnSimHtml::STATE3A_enter()
{
    this->stateId = StateId::STATE3A;
    
    // State3A behavior
    // uml: enter / { ActionD(); }
    {
        // Step 1: execute action `ActionD();`
        ActionD();
    } // end of behavior for State3A
}

void FsmBadnSimHtml::STATE3A_exit()
{
    this->stateId = StateId::STATE3;
}

void FsmBadnSimHtml::STATE3A_event1()
{
    // State3A behavior
    // uml: Event1 TransitionTo(State3B)
    {
        // Step 1: Exit states until we reach `State3` state (Least Common Ancestor for transition).
        STATE3A_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State3B`.
        STATE3B_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State3A
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE3B
////////////////////////////////////////////////////////////////////////////////

void FsmBadnSimHtml::STATE3B_enter()
{
    this->stateId = StateId::STATE3B;
}

void FsmBadnSimHtml::STATE3B_exit()
{
    // State3B behavior
    // uml: exit / { ActionE(); }
    {
        // Step 1: execute action `ActionE();`
        ActionE();
    } // end of behavior for State3B
    
    this->stateId = StateId::STATE3;
}

void FsmBadnSimHtml::STATE3B_event2()
{
    // State3B behavior
    // uml: Event2 TransitionTo(State3A)
    {
        // Step 1: Exit states until we reach `State3` state (Least Common Ancestor for transition).
        STATE3B_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State3A`.
        STATE3A_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State3B
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TERMINAL
////////////////////////////////////////////////////////////////////////////////

void FsmBadnSimHtml::TERMINAL_enter()
{
    this->stateId = StateId::TERMINAL;
}

void FsmBadnSimHtml::TERMINAL_exit()
{
    this->stateId = StateId::ROOT;
}

// Thread safe.
char const * FsmBadnSimHtml::stateIdToString(StateId id)
{
    switch (id)
    {
        case StateId::ROOT: return "ROOT";
        case StateId::STATE1: return "STATE1";
        case StateId::STATE2: return "STATE2";
        case StateId::STATE3: return "STATE3";
        case StateId::STATE3A: return "STATE3A";
        case StateId::STATE3B: return "STATE3B";
        case StateId::TERMINAL: return "TERMINAL";
        default: return "?";
    }
}

// Thread safe.
char const * FsmBadnSimHtml::eventIdToString(EventId id)
{
    switch (id)
    {
        case EventId::DO: return "DO";
        case EventId::EVENT1: return "EVENT1";
        case EventId::EVENT2: return "EVENT2";
        case EventId::EVENT3: return "EVENT3";
        default: return "?";
    }
}
