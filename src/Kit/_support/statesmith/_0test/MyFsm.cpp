// Autogenerated with StateSmith 0.19.0+b5719011215d41a81572ed347c02b22db5d1a48f. Last run: 2025-11-22 01:24:14 PM.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

/*
 * Copyright Integer Fox Authors
 *
 * Distributed under the BSD 3 Clause License. See the license agreement at:
 * https://github.com/Integerfox/kit.core/blob/main/LICENSE
 *
 * Redistributions of the source code must retain the above copyright notice.
*/

#include "MyFsm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
#include "Kit/System/Trace.h"
#include "Kit/System/FatalError.h"

namespace Foo {
namespace Bar {
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    void MyFsm::startFsm()
    {
        ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

            // ROOT.<InitialState> behavior
            // uml: / { ActionA(); } TransitionTo(State1)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: `ActionA();`.
                ActionA();

                // Step 3: Enter/move towards transition target `State1`.
                STATE1_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }

    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    void MyFsm::fsmDispatchEvent(EventId eventId)
    {
        switch (this->stateId)
        {
            // STATE: MyFsm
            case StateId::ROOT:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: State1
            case StateId::STATE1:
                switch (eventId)
                {
                    case EventId::EVENT1: STATE1_event1(); break;

                    default: break; // to avoid "unused enumeration value in switch" warning
                }
                break;

            // STATE: State2
            case StateId::STATE2:
                switch (eventId)
                {
                    case EventId::DO: STATE2_do(); break;
                    case EventId::EVENT3: STATE2_event3(); break;
                    case EventId::EVENT2: STATE2_event2(); break;

                    default: break; // to avoid "unused enumeration value in switch" warning
                }
                break;

            // STATE: State3
            case StateId::STATE3:
                switch (eventId)
                {
                    case EventId::EVENT3: STATE3_event3(); break;

                    default: break; // to avoid "unused enumeration value in switch" warning
                }
                break;

            // STATE: State3A
            case StateId::STATE3A:
                switch (eventId)
                {
                    case EventId::EVENT1: STATE3A_event1(); break;
                    case EventId::EVENT3: STATE3_event3(); break; // First ancestor handler for this event

                    default: break; // to avoid "unused enumeration value in switch" warning
                }
                break;

            // STATE: State3B
            case StateId::STATE3B:
                switch (eventId)
                {
                    case EventId::EVENT2: STATE3B_event2(); break;
                    case EventId::EVENT3: STATE3_event3(); break; // First ancestor handler for this event

                    default: break; // to avoid "unused enumeration value in switch" warning
                }
                break;

            // STATE: TERMINAL
            case StateId::TERMINAL:
                // No events handled by this state (or its ancestors).
                break;
        }

    }

    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    void MyFsm::exitUpToStateHandler(StateId desiredState)
    {
        while (this->stateId != desiredState)
        {
            switch (this->stateId)
            {
                case StateId::STATE1: STATE1_exit(); break;

                case StateId::STATE2: STATE2_exit(); break;

                case StateId::STATE3: STATE3_exit(); break;

                case StateId::STATE3A: STATE3A_exit(); break;

                case StateId::STATE3B: STATE3B_exit(); break;

                case StateId::TERMINAL: TERMINAL_exit(); break;

                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////

    void MyFsm::ROOT_enter()
    {
        this->stateId = StateId::ROOT;
    }

    void MyFsm::ROOT_ChoicePoint_j1__transition()
    {
        // ROOT.<ChoicePoint>(j1) behavior
        // uml: / { ActionG(); } TransitionTo(State3)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: `ActionG();`.
            ActionG();

            // Step 3: Enter/move towards transition target `State3`.
            STATE3_enter();

            // State3.<InitialState> behavior
            // uml: TransitionTo(State3A)
            {
                // Step 1: Exit states until we reach `State3` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `State3A`.
                STATE3A_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for State3.<InitialState>
        } // end of behavior for ROOT.<ChoicePoint>(j1)
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state STATE1
    ////////////////////////////////////////////////////////////////////////////////

    void MyFsm::STATE1_enter()
    {
        this->stateId = StateId::STATE1;
    }

    void MyFsm::STATE1_exit()
    {
        this->stateId = StateId::ROOT;
    }

    void MyFsm::STATE1_event1()
    {
        // State1 behavior
        // uml: Event1 TransitionTo(ROOT.<ChoicePoint>(c1))
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            STATE1_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(c1)`.
            // ROOT.<ChoicePoint>(c1) is a pseudo state and cannot have an `enter` trigger.

            // ROOT.<ChoicePoint>(c1) behavior
            // uml: [guard1()] / { ActionB(); } TransitionTo(State2)
            if (guard1())
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: `ActionB();`.
                ActionB();

                // Step 3: Enter/move towards transition target `State2`.
                STATE2_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<ChoicePoint>(c1)

            // ROOT.<ChoicePoint>(c1) behavior
            // uml: else / { ActionC(); } TransitionTo(ROOT.<ChoicePoint>(j1))
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: `ActionC();`.
                ActionC();

                // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(j1)`.
                // ROOT.<ChoicePoint>(j1) is a pseudo state and cannot have an `enter` trigger.

                // Finish transition by calling pseudo state transition function.
                ROOT_ChoicePoint_j1__transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ROOT.<ChoicePoint>(c1)
        } // end of behavior for State1

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state STATE2
    ////////////////////////////////////////////////////////////////////////////////

    void MyFsm::STATE2_enter()
    {
        this->stateId = StateId::STATE2;

        // State2 behavior
        // uml: enter / { ActionH();\nActionB(); }
        {
            // Step 1: execute action `ActionH();\nActionB();`
            ActionH();
            ActionB();
        } // end of behavior for State2
    }

    void MyFsm::STATE2_exit()
    {
        this->stateId = StateId::ROOT;
    }

    void MyFsm::STATE2_do()
    {
        // State2 behavior
        // uml: do / { ActionF(); }
        {
            // Step 1: execute action `ActionF();`
            ActionF();
        } // end of behavior for State2

        // No ancestor handles this event.
    }

    void MyFsm::STATE2_event2()
    {
        // State2 behavior
        // uml: Event2 TransitionTo(ROOT.<ChoicePoint>(j1))
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            STATE2_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(j1)`.
            // ROOT.<ChoicePoint>(j1) is a pseudo state and cannot have an `enter` trigger.

            // Finish transition by calling pseudo state transition function.
            ROOT_ChoicePoint_j1__transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for State2

        // No ancestor handles this event.
    }

    void MyFsm::STATE2_event3()
    {
        // State2 behavior
        // uml: Event3 TransitionTo(TERMINAL)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            STATE2_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `TERMINAL`.
            TERMINAL_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State2

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state STATE3
    ////////////////////////////////////////////////////////////////////////////////

    void MyFsm::STATE3_enter()
    {
        this->stateId = StateId::STATE3;
    }

    void MyFsm::STATE3_exit()
    {
        this->stateId = StateId::ROOT;
    }

    void MyFsm::STATE3_event3()
    {
        // State3 behavior
        // uml: Event3 / { ActionA(); } TransitionTo(State1)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            exitUpToStateHandler(StateId::ROOT);

            // Step 2: Transition action: `ActionA();`.
            ActionA();

            // Step 3: Enter/move towards transition target `State1`.
            STATE1_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State3

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state STATE3A
    ////////////////////////////////////////////////////////////////////////////////

    void MyFsm::STATE3A_enter()
    {
        this->stateId = StateId::STATE3A;

        // State3A behavior
        // uml: enter / { ActionD(); }
        {
            // Step 1: execute action `ActionD();`
            ActionD();
        } // end of behavior for State3A
    }

    void MyFsm::STATE3A_exit()
    {
        this->stateId = StateId::STATE3;
    }

    void MyFsm::STATE3A_event1()
    {
        // State3A behavior
        // uml: Event1 TransitionTo(State3B)
        {
            // Step 1: Exit states until we reach `State3` state (Least Common Ancestor for transition).
            STATE3A_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `State3B`.
            STATE3B_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State3A

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state STATE3B
    ////////////////////////////////////////////////////////////////////////////////

    void MyFsm::STATE3B_enter()
    {
        this->stateId = StateId::STATE3B;
    }

    void MyFsm::STATE3B_exit()
    {
        // State3B behavior
        // uml: exit / { ActionE(); }
        {
            // Step 1: execute action `ActionE();`
            ActionE();
        } // end of behavior for State3B

        this->stateId = StateId::STATE3;
    }

    void MyFsm::STATE3B_event2()
    {
        // State3B behavior
        // uml: Event2 TransitionTo(State3A)
        {
            // Step 1: Exit states until we reach `State3` state (Least Common Ancestor for transition).
            STATE3B_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `State3A`.
            STATE3A_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State3B

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TERMINAL
    ////////////////////////////////////////////////////////////////////////////////

    void MyFsm::TERMINAL_enter()
    {
        this->stateId = StateId::TERMINAL;
    }

    void MyFsm::TERMINAL_exit()
    {
        this->stateId = StateId::ROOT;
    }

    // Thread safe.
    char const * MyFsm::stateIdToString(StateId id)
    {
        switch (id)
        {
            case StateId::ROOT: return "ROOT";
            case StateId::STATE1: return "STATE1";
            case StateId::STATE2: return "STATE2";
            case StateId::STATE3: return "STATE3";
            case StateId::STATE3A: return "STATE3A";
            case StateId::STATE3B: return "STATE3B";
            case StateId::TERMINAL: return "TERMINAL";
            default: return "?";
        }
    }

    // Thread safe.
    char const * MyFsm::eventIdToString(EventId id)
    {
        switch (id)
        {
            case EventId::DO: return "DO";
            case EventId::EVENT1: return "EVENT1";
            case EventId::EVENT2: return "EVENT2";
            case EventId::EVENT3: return "EVENT3";
            default: return "?";
        }
    }

    void MyFsm::dispatchEvent( EventId msg )
    {
        static constexpr const char* tsection = "Foo::Bar";

        // Queue my event
        if ( !m_eventQueue.add( msg ) )
        {
            Kit::System::FatalError::logf( Kit::System::Shutdown::eFSM_EVENT_OVERFLOW, "%s(MyFsm): - Buffer Overflow!", tsection );
        }

        // Protect against in-thread 'feedback loops' that can potentially generate events
        if ( !m_processingFsmEvent )
        {
            m_processingFsmEvent = true;
            while ( m_eventQueue.remove( msg ) )
            {
                KIT_SYSTEM_TRACE_MSG( tsection, "EVENT:= %s, current state=%s ...", eventIdToString( msg ), stateIdToString(stateId) );
                fsmDispatchEvent( msg );
                KIT_SYSTEM_TRACE_MSG( tsection, "-->Completed: end state=%s", stateIdToString(stateId) );
            }

            m_processingFsmEvent = false;
        }
    }

}}
