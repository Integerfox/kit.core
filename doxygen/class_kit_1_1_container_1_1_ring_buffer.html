<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kit: Kit::Container::RingBuffer&lt; ITEM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.gif"/></td>
  <td id="projectalign">
   <div id="projectname">Kit<span id="projectnumber">&#160;Build: 220-main</span>
   </div>
   <div id="projectbrief">KIT Embedded C++ Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_kit.html">Kit</a></li><li class="navelem"><a class="el" href="namespace_kit_1_1_container.html">Container</a></li><li class="navelem"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">RingBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_kit_1_1_container_1_1_ring_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Kit::Container::RingBuffer&lt; ITEM &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This template class implements a Ring Buffer.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_ring_buffer_8h_source.html">RingBuffer.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Kit::Container::RingBuffer&lt; ITEM &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_kit_1_1_container_1_1_ring_buffer__inherit__graph.svg" width="1496" height="244"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for Kit::Container::RingBuffer&lt; ITEM &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_kit_1_1_container_1_1_ring_buffer__coll__graph.svg" width="230" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeae33a075bbf6ed87fbb3b16993d84ea" id="r_aeae33a075bbf6ed87fbb3b16993d84ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeae33a075bbf6ed87fbb3b16993d84ea">RingBuffer</a> (ITEM *memoryBuffer, unsigned N, bool initializeMemory=true)</td></tr>
<tr class="memdesc:aeae33a075bbf6ed87fbb3b16993d84ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:aeae33a075bbf6ed87fbb3b16993d84ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b350edc1e9c9f5a084e9739d45a3d1d" id="r_a4b350edc1e9c9f5a084e9739d45a3d1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b350edc1e9c9f5a084e9739d45a3d1d">add</a> (const ITEM &amp;item) noexcept</td></tr>
<tr class="memdesc:a4b350edc1e9c9f5a084e9739d45a3d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new item to the ring buffer.  <br /></td></tr>
<tr class="separator:a4b350edc1e9c9f5a084e9739d45a3d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d519398b6660f274b2264073265d9d9" id="r_a7d519398b6660f274b2264073265d9d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d519398b6660f274b2264073265d9d9">addElements</a> (unsigned numElementsAdded) noexcept</td></tr>
<tr class="memdesc:a7d519398b6660f274b2264073265d9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method 'adds' N elements - that were populated using the pointer returned from peekNextAddItems - to the ring buffer.  <br /></td></tr>
<tr class="separator:a7d519398b6660f274b2264073265d9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067ef2cf4a483997e7e85873f2efb4cd" id="r_a067ef2cf4a483997e7e85873f2efb4cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a067ef2cf4a483997e7e85873f2efb4cd">peekHead</a> (ITEM &amp;item) noexcept</td></tr>
<tr class="memdesc:a067ef2cf4a483997e7e85873f2efb4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inspects the head of the ring buffer without removing it.  <br /></td></tr>
<tr class="separator:a067ef2cf4a483997e7e85873f2efb4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e11b1cbd7fdd7ce120dbac9dc99d7cc" id="r_a1e11b1cbd7fdd7ce120dbac9dc99d7cc"><td class="memItemLeft" align="right" valign="top">ITEM *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e11b1cbd7fdd7ce120dbac9dc99d7cc">peekNextAddItems</a> (unsigned &amp;dstNumFlatElements) const noexcept</td></tr>
<tr class="memdesc:a1e11b1cbd7fdd7ce120dbac9dc99d7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the next item to be added.  <br /></td></tr>
<tr class="separator:a1e11b1cbd7fdd7ce120dbac9dc99d7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a70f0db2816455a7ae20cb39269efb2" id="r_a9a70f0db2816455a7ae20cb39269efb2"><td class="memItemLeft" align="right" valign="top">ITEM *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a70f0db2816455a7ae20cb39269efb2">peekNextRemoveItems</a> (unsigned &amp;dstNumFlatElements) const noexcept</td></tr>
<tr class="memdesc:a9a70f0db2816455a7ae20cb39269efb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the next item to be removed.  <br /></td></tr>
<tr class="separator:a9a70f0db2816455a7ae20cb39269efb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c986b1c6595fc1eca21d4e63427320" id="r_ac3c986b1c6595fc1eca21d4e63427320"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3c986b1c6595fc1eca21d4e63427320">peekTail</a> (ITEM &amp;item) noexcept</td></tr>
<tr class="memdesc:ac3c986b1c6595fc1eca21d4e63427320"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inspects the tail of the ring buffer without removing it.  <br /></td></tr>
<tr class="separator:ac3c986b1c6595fc1eca21d4e63427320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30609f25225a17178e151519e82f348" id="r_af30609f25225a17178e151519e82f348"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af30609f25225a17178e151519e82f348">remove</a> (ITEM &amp;item) noexcept</td></tr>
<tr class="memdesc:af30609f25225a17178e151519e82f348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an item from the ring buffer.  <br /></td></tr>
<tr class="separator:af30609f25225a17178e151519e82f348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50c280cca8d9768293c5572efe2fa8" id="r_a7a50c280cca8d9768293c5572efe2fa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a50c280cca8d9768293c5572efe2fa8">removeElements</a> (unsigned numElementsToRemove) noexcept</td></tr>
<tr class="memdesc:a7a50c280cca8d9768293c5572efe2fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method 'removes' N elements - that were removed using the pointer returned from peekNextRemoveItems - from the ring buffer.  <br /></td></tr>
<tr class="separator:a7a50c280cca8d9768293c5572efe2fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_kit_1_1_container_1_1_ring_buffer_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html">Kit::Container::RingBufferBase</a></td></tr>
<tr class="memitem:a9847a7b75185ab0fb0c759c587adf36e inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_a9847a7b75185ab0fb0c759c587adf36e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#a9847a7b75185ab0fb0c759c587adf36e">clearTheBuffer</a> () noexcept</td></tr>
<tr class="memdesc:a9847a7b75185ab0fb0c759c587adf36e inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method resets the underlying read/write indexes, i.e.  <br /></td></tr>
<tr class="separator:a9847a7b75185ab0fb0c759c587adf36e inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420a299a57b6388cd679ce79f464548 inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_ac420a299a57b6388cd679ce79f464548"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#ac420a299a57b6388cd679ce79f464548">getMaxItems</a> () const noexcept</td></tr>
<tr class="memdesc:ac420a299a57b6388cd679ce79f464548 inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the maximum number of items that can be stored in the Ring buffer.  <br /></td></tr>
<tr class="separator:ac420a299a57b6388cd679ce79f464548 inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6007f916f97521bdd5effec278704a2c inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_a6007f916f97521bdd5effec278704a2c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#a6007f916f97521bdd5effec278704a2c">getNumItems</a> () const noexcept</td></tr>
<tr class="memdesc:a6007f916f97521bdd5effec278704a2c inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the CURRENT number of elements in the Ring Buffer.  <br /></td></tr>
<tr class="separator:a6007f916f97521bdd5effec278704a2c inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f049473b9c8e2f8967225a5549ad04 inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_af4f049473b9c8e2f8967225a5549ad04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#af4f049473b9c8e2f8967225a5549ad04">isEmpty</a> () const noexcept</td></tr>
<tr class="memdesc:af4f049473b9c8e2f8967225a5549ad04 inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true if the Ring Buffer is empty.  <br /></td></tr>
<tr class="separator:af4f049473b9c8e2f8967225a5549ad04 inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac716a342d9dfdf34656e4aca36e60f inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_a7ac716a342d9dfdf34656e4aca36e60f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#a7ac716a342d9dfdf34656e4aca36e60f">isFull</a> () const noexcept</td></tr>
<tr class="memdesc:a7ac716a342d9dfdf34656e4aca36e60f inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true if the Ring Buffer is full.  <br /></td></tr>
<tr class="separator:a7ac716a342d9dfdf34656e4aca36e60f inherit pub_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a871717c2d544a72a74d44985ec55eb7c" id="r_a871717c2d544a72a74d44985ec55eb7c"><td class="memItemLeft" align="right" valign="top">ITEM *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a871717c2d544a72a74d44985ec55eb7c">m_bufferMemory</a></td></tr>
<tr class="memdesc:a871717c2d544a72a74d44985ec55eb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_kit_1_1_memory.html" title="The Memory namespace provides a collection interfaces that deal with memory specific/related behavior...">Memory</a> for the Ring buffer.  <br /></td></tr>
<tr class="separator:a871717c2d544a72a74d44985ec55eb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html">Kit::Container::RingBufferBase</a></td></tr>
<tr class="memitem:abbeba728c6d3a3a48aec9713729d94dc inherit pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base" id="r_abbeba728c6d3a3a48aec9713729d94dc"><td class="memItemLeft" align="right" valign="top">const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#abbeba728c6d3a3a48aec9713729d94dc">m_elements</a></td></tr>
<tr class="memdesc:abbeba728c6d3a3a48aec9713729d94dc inherit pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of element in the 'ring memory.  <br /></td></tr>
<tr class="separator:abbeba728c6d3a3a48aec9713729d94dc inherit pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021897c37869286443aff3e8837a9e8c inherit pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base" id="r_a021897c37869286443aff3e8837a9e8c"><td class="memItemLeft" align="right" valign="top">volatile unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#a021897c37869286443aff3e8837a9e8c">m_readIdx</a></td></tr>
<tr class="memdesc:a021897c37869286443aff3e8837a9e8c inherit pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the next item to be read from the ring.  <br /></td></tr>
<tr class="separator:a021897c37869286443aff3e8837a9e8c inherit pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eafc28324bee46be7256f60e68952a inherit pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base" id="r_aa1eafc28324bee46be7256f60e68952a"><td class="memItemLeft" align="right" valign="top">volatile unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#aa1eafc28324bee46be7256f60e68952a">m_writeIdx</a></td></tr>
<tr class="memdesc:aa1eafc28324bee46be7256f60e68952a inherit pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the next item to be added to the ring.  <br /></td></tr>
<tr class="separator:aa1eafc28324bee46be7256f60e68952a inherit pro_attribs_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_kit_1_1_container_1_1_ring_buffer_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html">Kit::Container::RingBufferBase</a></td></tr>
<tr class="memitem:af201d9c3b3512b2f457857af12e4d2f5 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_af201d9c3b3512b2f457857af12e4d2f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#af201d9c3b3512b2f457857af12e4d2f5">RingBufferBase</a> (unsigned numMaxElements) noexcept</td></tr>
<tr class="memdesc:af201d9c3b3512b2f457857af12e4d2f5 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:af201d9c3b3512b2f457857af12e4d2f5 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57364a875a5e3f058fe4b2ae9773cc6 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_ad57364a875a5e3f058fe4b2ae9773cc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#ad57364a875a5e3f058fe4b2ae9773cc6">add</a> (const void *elemPtr, size_t elemSize, void *dstRingBufMemory) noexcept</td></tr>
<tr class="memdesc:ad57364a875a5e3f058fe4b2ae9773cc6 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new item to the Ring Buffer as the last item in the buffer.  <br /></td></tr>
<tr class="separator:ad57364a875a5e3f058fe4b2ae9773cc6 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbce39b73b5a09a45c162cde1aceed48 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_afbce39b73b5a09a45c162cde1aceed48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#afbce39b73b5a09a45c162cde1aceed48">addElements</a> (unsigned numElementsAdded) noexcept</td></tr>
<tr class="memdesc:afbce39b73b5a09a45c162cde1aceed48 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method 'adds' N elements - that were populated using the pointer returned from peekNextAddItems - to the ring buffer.  <br /></td></tr>
<tr class="separator:afbce39b73b5a09a45c162cde1aceed48 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74d2b72b63d6cf7a716bfb2aa179796 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_af74d2b72b63d6cf7a716bfb2aa179796"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#af74d2b72b63d6cf7a716bfb2aa179796">peekHead</a> (void *elemPtr, size_t elemSize, const void *srcRingBufMemory) noexcept</td></tr>
<tr class="memdesc:af74d2b72b63d6cf7a716bfb2aa179796 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inspects the head element of the Ring buffer without removing it.  <br /></td></tr>
<tr class="separator:af74d2b72b63d6cf7a716bfb2aa179796 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cab22770ae1b490ef95e836422d5438 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_a6cab22770ae1b490ef95e836422d5438"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#a6cab22770ae1b490ef95e836422d5438">peekNextAddItems</a> (unsigned &amp;dstNumFlatElements, size_t elemSize, const void *srcRingBufMemory) const noexcept</td></tr>
<tr class="memdesc:a6cab22770ae1b490ef95e836422d5438 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the next item to be added.  <br /></td></tr>
<tr class="separator:a6cab22770ae1b490ef95e836422d5438 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fd1c461ee81e9d520ded2a742d5aaa inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_aa4fd1c461ee81e9d520ded2a742d5aaa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#aa4fd1c461ee81e9d520ded2a742d5aaa">peekNextRemoveItems</a> (unsigned &amp;dstNumFlatElements, size_t elemSize, const void *srcRingBufMemory) const noexcept</td></tr>
<tr class="memdesc:aa4fd1c461ee81e9d520ded2a742d5aaa inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the next item to be removed.  <br /></td></tr>
<tr class="separator:aa4fd1c461ee81e9d520ded2a742d5aaa inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b084312199071dec5d5f17fd5711d4 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_a63b084312199071dec5d5f17fd5711d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#a63b084312199071dec5d5f17fd5711d4">peekTail</a> (void *elemPtr, size_t elemSize, const void *srcRingBufMemory) noexcept</td></tr>
<tr class="memdesc:a63b084312199071dec5d5f17fd5711d4 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inspects the tail element of the Ring buffer without removing it.  <br /></td></tr>
<tr class="separator:a63b084312199071dec5d5f17fd5711d4 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc6c8b8d2fc9fd3e963e873e17f01eb inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_a3dc6c8b8d2fc9fd3e963e873e17f01eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#a3dc6c8b8d2fc9fd3e963e873e17f01eb">remove</a> (void *elemPtr, size_t elemSize, const void *srcRingBufMemory) noexcept</td></tr>
<tr class="memdesc:a3dc6c8b8d2fc9fd3e963e873e17f01eb inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first item in the Ring buffer.  <br /></td></tr>
<tr class="separator:a3dc6c8b8d2fc9fd3e963e873e17f01eb inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f8a745650981c99f1f03ab875ac657 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base" id="r_ae3f8a745650981c99f1f03ab875ac657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html#ae3f8a745650981c99f1f03ab875ac657">removeElements</a> (unsigned numElementsToRemove) noexcept</td></tr>
<tr class="memdesc:ae3f8a745650981c99f1f03ab875ac657 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method 'removes' N elements - that were removed using the pointer returned from peekNextRemoveItems - from the ring buffer.  <br /></td></tr>
<tr class="separator:ae3f8a745650981c99f1f03ab875ac657 inherit pro_methods_class_kit_1_1_container_1_1_ring_buffer_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ITEM&gt;<br />
class Kit::Container::RingBuffer&lt; ITEM &gt;</div><p>This template class implements a Ring Buffer. </p>
<p>A Ring Buffer instance IS ISR/Thread safe WHEN using a SINGLE Producer and SINGLE consumer of the buffer. See the <a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html" title="This &#39;implementation&#39; class provide the base functionality for a ring buffer.">RingBufferBase</a> class for additional details.</p>
<p>There is a set of methods that allow the application direct memory access - AS A LINEAR BUFFER - to a subset of the ring buffer's data. At any given time the size of the linear buffer is restricted to the amount of data that can be accessed without 'wrapping' the ring buffer memory space. The intended use case for these methods is for bulk copy operations (e.g populating a FIFO or a DMA buffer). <a class="el" href="#a9a70f0db2816455a7ae20cb39269efb2" title="This method returns a pointer to the next item to be removed.">peekNextRemoveItems()</a> <a class="el" href="#a7a50c280cca8d9768293c5572efe2fa8" title="This method &#39;removes&#39; N elements - that were removed using the pointer returned from peekNextRemoveIt...">removeElements()</a> <a class="el" href="#a1e11b1cbd7fdd7ce120dbac9dc99d7cc" title="This method returns a pointer to the next item to be added.">peekNextAddItems()</a> <a class="el" href="#a7d519398b6660f274b2264073265d9d9" title="This method &#39;adds&#39; N elements - that were populated using the pointer returned from peekNextAddItems ...">addElements()</a></p>
<p>Template Args: ITEM:= <a class="el" href="namespace_kit_1_1_type.html" title="The Type namespace provides various types that are not unique to a single namespace.">Type</a> of the data stored in the Ring Buffer </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeae33a075bbf6ed87fbb3b16993d84ea" name="aeae33a075bbf6ed87fbb3b16993d84ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae33a075bbf6ed87fbb3b16993d84ea">&#9670;&#160;</a></span>RingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::RingBuffer </td>
          <td>(</td>
          <td class="paramtype">ITEM *</td>          <td class="paramname"><span class="paramname"><em>memoryBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>initializeMemory</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4b350edc1e9c9f5a084e9739d45a3d1d" name="a4b350edc1e9c9f5a084e9739d45a3d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b350edc1e9c9f5a084e9739d45a3d1d">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const ITEM &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds new item to the ring buffer. </p>
<p>Returns true on success. If the ring buffer is full, then false is returned (and ring buffer is not updated). </p>

</div>
</div>
<a id="a7d519398b6660f274b2264073265d9d9" name="a7d519398b6660f274b2264073265d9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d519398b6660f274b2264073265d9d9">&#9670;&#160;</a></span>addElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::addElements </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>numElementsAdded</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method 'adds' N elements - that were populated using the pointer returned from peekNextAddItems - to the ring buffer. </p>
<p>Basically its updates the write index to reflect items added using direct memory access.</p>
<p>'numElementsAdded' be less than or equal to the 'dstNumFlatElements' returned from <a class="el" href="#a1e11b1cbd7fdd7ce120dbac9dc99d7cc" title="This method returns a pointer to the next item to be added.">peekNextAddItems()</a>.</p>
<p>CAUTION: IF YOU DON'T UNDERSTAND THE USE CASE FOR THIS METHOD - THEN DON'T USE IT. If this method is used improperly, it WILL CORRUPT the Ring Buffer! </p>

</div>
</div>
<a id="a067ef2cf4a483997e7e85873f2efb4cd" name="a067ef2cf4a483997e7e85873f2efb4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067ef2cf4a483997e7e85873f2efb4cd">&#9670;&#160;</a></span>peekHead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::peekHead </td>
          <td>(</td>
          <td class="paramtype">ITEM &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inspects the head of the ring buffer without removing it. </p>
<p>The contents of the head element will be copied into the 'item' argument. The method returns true if the operation was successful; else false is returned, i.e. the Ring buffer is empty. </p>

</div>
</div>
<a id="a1e11b1cbd7fdd7ce120dbac9dc99d7cc" name="a1e11b1cbd7fdd7ce120dbac9dc99d7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e11b1cbd7fdd7ce120dbac9dc99d7cc">&#9670;&#160;</a></span>peekNextAddItems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITEM * <a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::peekNextAddItems </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>dstNumFlatElements</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a pointer to the next item to be added. </p>
<p>In addition it returns the number of elements that can be added as linear/flat buffer (i.e. without wrapping around raw buffer memory)</p>
<p>If the Ring buffer is full, a null pointer is returned </p>

</div>
</div>
<a id="a9a70f0db2816455a7ae20cb39269efb2" name="a9a70f0db2816455a7ae20cb39269efb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a70f0db2816455a7ae20cb39269efb2">&#9670;&#160;</a></span>peekNextRemoveItems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITEM * <a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::peekNextRemoveItems </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>dstNumFlatElements</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a pointer to the next item to be removed. </p>
<p>In addition it returns the number of elements that can be removed as linear/flat buffer (i.e. without wrapping around raw buffer memory)</p>
<p>If the Ring buffer is empty, a null pointer is returned </p>

</div>
</div>
<a id="ac3c986b1c6595fc1eca21d4e63427320" name="ac3c986b1c6595fc1eca21d4e63427320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c986b1c6595fc1eca21d4e63427320">&#9670;&#160;</a></span>peekTail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::peekTail </td>
          <td>(</td>
          <td class="paramtype">ITEM &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inspects the tail of the ring buffer without removing it. </p>
<p>The contents of the tail element will be copied into the 'item' argument. The method returns true if the operation was successful; else false is returned, i.e. the Ring buffer is empty. </p>

</div>
</div>
<a id="af30609f25225a17178e151519e82f348" name="af30609f25225a17178e151519e82f348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30609f25225a17178e151519e82f348">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">ITEM &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an item from the ring buffer. </p>
<p>Returns true on success. If the ring buffer is empty, then false is returned (and the 'item' argument is not updated) </p>

</div>
</div>
<a id="a7a50c280cca8d9768293c5572efe2fa8" name="a7a50c280cca8d9768293c5572efe2fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a50c280cca8d9768293c5572efe2fa8">&#9670;&#160;</a></span>removeElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::removeElements </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>numElementsToRemove</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method 'removes' N elements - that were removed using the pointer returned from peekNextRemoveItems - from the ring buffer. </p>
<p>Basically it updates the read index to reflect items removed using direct memory access.</p>
<p>'numElementsToRemove' be less than or equal to the 'dstNumFlatElements' returned from <a class="el" href="#a9a70f0db2816455a7ae20cb39269efb2" title="This method returns a pointer to the next item to be removed.">peekNextRemoveItems()</a>.</p>
<p>CAUTION: IF YOU DON'T UNDERSTAND THE USE CASE FOR THIS METHOD - THEN DON'T USE IT. If this method is used improperly, it WILL CORRUPT the Ring Buffer! </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a871717c2d544a72a74d44985ec55eb7c" name="a871717c2d544a72a74d44985ec55eb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871717c2d544a72a74d44985ec55eb7c">&#9670;&#160;</a></span>m_bufferMemory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITEM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITEM* <a class="el" href="class_kit_1_1_container_1_1_ring_buffer.html">Kit::Container::RingBuffer</a>&lt; ITEM &gt;::m_bufferMemory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_kit_1_1_memory.html" title="The Memory namespace provides a collection interfaces that deal with memory specific/related behavior...">Memory</a> for the Ring buffer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Kit/Container/<a class="el" href="_ring_buffer_8h_source.html">RingBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 2 2025 03:51:15 for Kit by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
