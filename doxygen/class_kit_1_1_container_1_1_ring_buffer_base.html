<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kit: Kit::Container::RingBufferBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.gif"/></td>
  <td id="projectalign">
   <div id="projectname">Kit<span id="projectnumber">&#160;Build: 216-main</span>
   </div>
   <div id="projectbrief">KIT Embedded C++ Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_kit.html">Kit</a></li><li class="navelem"><a class="el" href="namespace_kit_1_1_container.html">Container</a></li><li class="navelem"><a class="el" href="class_kit_1_1_container_1_1_ring_buffer_base.html">RingBufferBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_kit_1_1_container_1_1_ring_buffer_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Kit::Container::RingBufferBase Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This 'implementation' class provide the base functionality for a ring buffer.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_ring_buffer_base_8h_source.html">RingBufferBase.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Kit::Container::RingBufferBase:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_kit_1_1_container_1_1_ring_buffer_base__inherit__graph.svg" width="408" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9847a7b75185ab0fb0c759c587adf36e" id="r_a9847a7b75185ab0fb0c759c587adf36e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9847a7b75185ab0fb0c759c587adf36e">clearTheBuffer</a> () noexcept</td></tr>
<tr class="memdesc:a9847a7b75185ab0fb0c759c587adf36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method resets the underlying read/write indexes, i.e.  <br /></td></tr>
<tr class="separator:a9847a7b75185ab0fb0c759c587adf36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420a299a57b6388cd679ce79f464548" id="r_ac420a299a57b6388cd679ce79f464548"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac420a299a57b6388cd679ce79f464548">getMaxItems</a> () const noexcept</td></tr>
<tr class="memdesc:ac420a299a57b6388cd679ce79f464548"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the maximum number of items that can be stored in the Ring buffer.  <br /></td></tr>
<tr class="separator:ac420a299a57b6388cd679ce79f464548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6007f916f97521bdd5effec278704a2c" id="r_a6007f916f97521bdd5effec278704a2c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6007f916f97521bdd5effec278704a2c">getNumItems</a> () const noexcept</td></tr>
<tr class="memdesc:a6007f916f97521bdd5effec278704a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the CURRENT number of elements in the Ring Buffer.  <br /></td></tr>
<tr class="separator:a6007f916f97521bdd5effec278704a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f049473b9c8e2f8967225a5549ad04" id="r_af4f049473b9c8e2f8967225a5549ad04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4f049473b9c8e2f8967225a5549ad04">isEmpty</a> () const noexcept</td></tr>
<tr class="memdesc:af4f049473b9c8e2f8967225a5549ad04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true if the Ring Buffer is empty.  <br /></td></tr>
<tr class="separator:af4f049473b9c8e2f8967225a5549ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac716a342d9dfdf34656e4aca36e60f" id="r_a7ac716a342d9dfdf34656e4aca36e60f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ac716a342d9dfdf34656e4aca36e60f">isFull</a> () const noexcept</td></tr>
<tr class="memdesc:a7ac716a342d9dfdf34656e4aca36e60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true if the Ring Buffer is full.  <br /></td></tr>
<tr class="separator:a7ac716a342d9dfdf34656e4aca36e60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af201d9c3b3512b2f457857af12e4d2f5" id="r_af201d9c3b3512b2f457857af12e4d2f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af201d9c3b3512b2f457857af12e4d2f5">RingBufferBase</a> (unsigned numMaxElements) noexcept</td></tr>
<tr class="memdesc:af201d9c3b3512b2f457857af12e4d2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:af201d9c3b3512b2f457857af12e4d2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57364a875a5e3f058fe4b2ae9773cc6" id="r_ad57364a875a5e3f058fe4b2ae9773cc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad57364a875a5e3f058fe4b2ae9773cc6">add</a> (const void *elemPtr, size_t elemSize, void *dstRingBufMemory) noexcept</td></tr>
<tr class="memdesc:ad57364a875a5e3f058fe4b2ae9773cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new item to the Ring Buffer as the last item in the buffer.  <br /></td></tr>
<tr class="separator:ad57364a875a5e3f058fe4b2ae9773cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbce39b73b5a09a45c162cde1aceed48" id="r_afbce39b73b5a09a45c162cde1aceed48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbce39b73b5a09a45c162cde1aceed48">addElements</a> (unsigned numElementsAdded) noexcept</td></tr>
<tr class="memdesc:afbce39b73b5a09a45c162cde1aceed48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method 'adds' N elements - that were populated using the pointer returned from peekNextAddItems - to the ring buffer.  <br /></td></tr>
<tr class="separator:afbce39b73b5a09a45c162cde1aceed48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74d2b72b63d6cf7a716bfb2aa179796" id="r_af74d2b72b63d6cf7a716bfb2aa179796"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af74d2b72b63d6cf7a716bfb2aa179796">peekHead</a> (void *elemPtr, size_t elemSize, const void *srcRingBufMemory) noexcept</td></tr>
<tr class="memdesc:af74d2b72b63d6cf7a716bfb2aa179796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inspects the head element of the Ring buffer without removing it.  <br /></td></tr>
<tr class="separator:af74d2b72b63d6cf7a716bfb2aa179796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cab22770ae1b490ef95e836422d5438" id="r_a6cab22770ae1b490ef95e836422d5438"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cab22770ae1b490ef95e836422d5438">peekNextAddItems</a> (unsigned &amp;dstNumFlatElements, size_t elemSize, const void *srcRingBufMemory) const noexcept</td></tr>
<tr class="memdesc:a6cab22770ae1b490ef95e836422d5438"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the next item to be added.  <br /></td></tr>
<tr class="separator:a6cab22770ae1b490ef95e836422d5438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fd1c461ee81e9d520ded2a742d5aaa" id="r_aa4fd1c461ee81e9d520ded2a742d5aaa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4fd1c461ee81e9d520ded2a742d5aaa">peekNextRemoveItems</a> (unsigned &amp;dstNumFlatElements, size_t elemSize, const void *srcRingBufMemory) const noexcept</td></tr>
<tr class="memdesc:aa4fd1c461ee81e9d520ded2a742d5aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the next item to be removed.  <br /></td></tr>
<tr class="separator:aa4fd1c461ee81e9d520ded2a742d5aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b084312199071dec5d5f17fd5711d4" id="r_a63b084312199071dec5d5f17fd5711d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63b084312199071dec5d5f17fd5711d4">peekTail</a> (void *elemPtr, size_t elemSize, const void *srcRingBufMemory) noexcept</td></tr>
<tr class="memdesc:a63b084312199071dec5d5f17fd5711d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inspects the tail element of the Ring buffer without removing it.  <br /></td></tr>
<tr class="separator:a63b084312199071dec5d5f17fd5711d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc6c8b8d2fc9fd3e963e873e17f01eb" id="r_a3dc6c8b8d2fc9fd3e963e873e17f01eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dc6c8b8d2fc9fd3e963e873e17f01eb">remove</a> (void *elemPtr, size_t elemSize, const void *srcRingBufMemory) noexcept</td></tr>
<tr class="memdesc:a3dc6c8b8d2fc9fd3e963e873e17f01eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first item in the Ring buffer.  <br /></td></tr>
<tr class="separator:a3dc6c8b8d2fc9fd3e963e873e17f01eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f8a745650981c99f1f03ab875ac657" id="r_ae3f8a745650981c99f1f03ab875ac657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3f8a745650981c99f1f03ab875ac657">removeElements</a> (unsigned numElementsToRemove) noexcept</td></tr>
<tr class="memdesc:ae3f8a745650981c99f1f03ab875ac657"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method 'removes' N elements - that were removed using the pointer returned from peekNextRemoveItems - from the ring buffer.  <br /></td></tr>
<tr class="separator:ae3f8a745650981c99f1f03ab875ac657"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abbeba728c6d3a3a48aec9713729d94dc" id="r_abbeba728c6d3a3a48aec9713729d94dc"><td class="memItemLeft" align="right" valign="top">const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbeba728c6d3a3a48aec9713729d94dc">m_elements</a></td></tr>
<tr class="memdesc:abbeba728c6d3a3a48aec9713729d94dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of element in the 'ring memory.  <br /></td></tr>
<tr class="separator:abbeba728c6d3a3a48aec9713729d94dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021897c37869286443aff3e8837a9e8c" id="r_a021897c37869286443aff3e8837a9e8c"><td class="memItemLeft" align="right" valign="top">volatile unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a021897c37869286443aff3e8837a9e8c">m_readIdx</a></td></tr>
<tr class="memdesc:a021897c37869286443aff3e8837a9e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the next item to be read from the ring.  <br /></td></tr>
<tr class="separator:a021897c37869286443aff3e8837a9e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eafc28324bee46be7256f60e68952a" id="r_aa1eafc28324bee46be7256f60e68952a"><td class="memItemLeft" align="right" valign="top">volatile unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1eafc28324bee46be7256f60e68952a">m_writeIdx</a></td></tr>
<tr class="memdesc:aa1eafc28324bee46be7256f60e68952a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the next item to be added to the ring.  <br /></td></tr>
<tr class="separator:aa1eafc28324bee46be7256f60e68952a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This 'implementation' class provide the base functionality for a ring buffer. </p>
<p>The Ring buffer is ISR/Thread safe as long as following constraints are met:</p><ul>
<li>Writing to an 'unsigned' data type is an atomic machine instruction.</li>
<li>There is SINGLE producer (add) and a SINGLE consumer (remove)</li>
</ul>
<p>NOTE: This class is not intended to be used directly. A child class is required to provide the ring buffer memory and type safety. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af201d9c3b3512b2f457857af12e4d2f5" name="af201d9c3b3512b2f457857af12e4d2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af201d9c3b3512b2f457857af12e4d2f5">&#9670;&#160;</a></span>RingBufferBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Kit::Container::RingBufferBase::RingBufferBase </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>numMaxElements</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad57364a875a5e3f058fe4b2ae9773cc6" name="ad57364a875a5e3f058fe4b2ae9773cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57364a875a5e3f058fe4b2ae9773cc6">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Kit::Container::RingBufferBase::add </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>elemPtr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>elemSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dstRingBufMemory</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new item to the Ring Buffer as the last item in the buffer. </p>
<p>The contents of the source item (aka 'elemPtr') will be copied into the Ring Buffer. Returns true if the operation was successful; else false is returned, i.e. the Buffer was full prior to the attempted <a class="el" href="#ad57364a875a5e3f058fe4b2ae9773cc6" title="Add a new item to the Ring Buffer as the last item in the buffer.">add()</a>. </p>

</div>
</div>
<a id="afbce39b73b5a09a45c162cde1aceed48" name="afbce39b73b5a09a45c162cde1aceed48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbce39b73b5a09a45c162cde1aceed48">&#9670;&#160;</a></span>addElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Kit::Container::RingBufferBase::addElements </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>numElementsAdded</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method 'adds' N elements - that were populated using the pointer returned from peekNextAddItems - to the ring buffer. </p>
<p>Basically its updates the tail pointer to reflect items added using direct memory access.</p>
<p>'numElementsAdded' be less than or equal to the 'dstNumFlatElements' returned from <a class="el" href="#a6cab22770ae1b490ef95e836422d5438" title="This method returns a pointer to the next item to be added.">peekNextAddItems()</a>.</p>
<p>CAUTION: IF YOU DON'T UNDERSTAND THE USE CASE FOR THIS METHOD - THEN DON'T USE IT. If this method is used improperly, it WILL CORRUPT the Ring Buffer! </p>

</div>
</div>
<a id="a9847a7b75185ab0fb0c759c587adf36e" name="a9847a7b75185ab0fb0c759c587adf36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9847a7b75185ab0fb0c759c587adf36e">&#9670;&#160;</a></span>clearTheBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Kit::Container::RingBufferBase::clearTheBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method resets the underlying read/write indexes, i.e. </p>
<p>effectively clearing the Ring Buffer contents. This method can ONLY BE USED when the Ring Buffer is NOT in use. It is the application's responsibility for ensuring this condition is met. </p>

</div>
</div>
<a id="ac420a299a57b6388cd679ce79f464548" name="ac420a299a57b6388cd679ce79f464548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac420a299a57b6388cd679ce79f464548">&#9670;&#160;</a></span>getMaxItems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Kit::Container::RingBufferBase::getMaxItems </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the maximum number of items that can be stored in the Ring buffer. </p>

</div>
</div>
<a id="a6007f916f97521bdd5effec278704a2c" name="a6007f916f97521bdd5effec278704a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6007f916f97521bdd5effec278704a2c">&#9670;&#160;</a></span>getNumItems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Kit::Container::RingBufferBase::getNumItems </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the CURRENT number of elements in the Ring Buffer. </p>

</div>
</div>
<a id="af4f049473b9c8e2f8967225a5549ad04" name="af4f049473b9c8e2f8967225a5549ad04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f049473b9c8e2f8967225a5549ad04">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Kit::Container::RingBufferBase::isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns true if the Ring Buffer is empty. </p>

</div>
</div>
<a id="a7ac716a342d9dfdf34656e4aca36e60f" name="a7ac716a342d9dfdf34656e4aca36e60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac716a342d9dfdf34656e4aca36e60f">&#9670;&#160;</a></span>isFull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Kit::Container::RingBufferBase::isFull </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns true if the Ring Buffer is full. </p>

</div>
</div>
<a id="af74d2b72b63d6cf7a716bfb2aa179796" name="af74d2b72b63d6cf7a716bfb2aa179796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74d2b72b63d6cf7a716bfb2aa179796">&#9670;&#160;</a></span>peekHead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Kit::Container::RingBufferBase::peekHead </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>elemPtr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>elemSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>srcRingBufMemory</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inspects the head element of the Ring buffer without removing it. </p>
<p>The contents of the head element will be copied into the 'elemPtr' argument. The method returns true if the operation was successful; else false is returned, i.e. the Ring buffer is empty. </p>

</div>
</div>
<a id="a6cab22770ae1b490ef95e836422d5438" name="a6cab22770ae1b490ef95e836422d5438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cab22770ae1b490ef95e836422d5438">&#9670;&#160;</a></span>peekNextAddItems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * Kit::Container::RingBufferBase::peekNextAddItems </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>dstNumFlatElements</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>elemSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>srcRingBufMemory</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a pointer to the next item to be added. </p>
<p>In addition it returns the number of elements that can be added as linear/flat buffer (i.e. without wrapping around raw buffer memory)</p>
<p>If the Ring buffer is full, a null pointer is returned </p>

</div>
</div>
<a id="aa4fd1c461ee81e9d520ded2a742d5aaa" name="aa4fd1c461ee81e9d520ded2a742d5aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fd1c461ee81e9d520ded2a742d5aaa">&#9670;&#160;</a></span>peekNextRemoveItems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * Kit::Container::RingBufferBase::peekNextRemoveItems </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>dstNumFlatElements</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>elemSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>srcRingBufMemory</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a pointer to the next item to be removed. </p>
<p>In addition it returns the number of elements that can be removed as linear/flat buffer (i.e. without wrapping around raw buffer memory).</p>
<p>The returned pointer and element count are only valid till the next read/remove operation.</p>
<p>If the Ring buffer is empty, a null pointer is returned </p>

</div>
</div>
<a id="a63b084312199071dec5d5f17fd5711d4" name="a63b084312199071dec5d5f17fd5711d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b084312199071dec5d5f17fd5711d4">&#9670;&#160;</a></span>peekTail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Kit::Container::RingBufferBase::peekTail </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>elemPtr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>elemSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>srcRingBufMemory</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inspects the tail element of the Ring buffer without removing it. </p>
<p>The contents of the tail element will be copied into the 'elemPtr' argument. The method returns true if the operation was successful; else false is returned, i.e. the Ring buffer is empty. </p>

</div>
</div>
<a id="a3dc6c8b8d2fc9fd3e963e873e17f01eb" name="a3dc6c8b8d2fc9fd3e963e873e17f01eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc6c8b8d2fc9fd3e963e873e17f01eb">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Kit::Container::RingBufferBase::remove </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>elemPtr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>elemSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>srcRingBufMemory</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first item in the Ring buffer. </p>
<p>The contents of the removed item will be copied into the 'elemPtr' argument. The method returns true if the operation was successful; else false is returned, i.e. the Ring buffer is/was empty. </p>

</div>
</div>
<a id="ae3f8a745650981c99f1f03ab875ac657" name="ae3f8a745650981c99f1f03ab875ac657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f8a745650981c99f1f03ab875ac657">&#9670;&#160;</a></span>removeElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Kit::Container::RingBufferBase::removeElements </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>numElementsToRemove</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method 'removes' N elements - that were removed using the pointer returned from peekNextRemoveItems - from the ring buffer. </p>
<p>Basically it updates the head pointer to reflect items removed using direct memory access.</p>
<p>'numElementsToRemove' be less than or equal to the 'dstNumFlatElements' returned from <a class="el" href="#aa4fd1c461ee81e9d520ded2a742d5aaa" title="This method returns a pointer to the next item to be removed.">peekNextRemoveItems()</a>.</p>
<p>CAUTION: IF YOU DON'T UNDERSTAND THE USE CASE FOR THIS METHOD - THEN DON'T USE IT. If this method is used improperly, it WILL CORRUPT the Ring Buffer! </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abbeba728c6d3a3a48aec9713729d94dc" name="abbeba728c6d3a3a48aec9713729d94dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbeba728c6d3a3a48aec9713729d94dc">&#9670;&#160;</a></span>m_elements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Kit::Container::RingBufferBase::m_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of element in the 'ring memory. </p>

</div>
</div>
<a id="a021897c37869286443aff3e8837a9e8c" name="a021897c37869286443aff3e8837a9e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021897c37869286443aff3e8837a9e8c">&#9670;&#160;</a></span>m_readIdx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile unsigned Kit::Container::RingBufferBase::m_readIdx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of the next item to be read from the ring. </p>
<p>This variable is only updated when a read operation is performed. In addition, the variable is atomically updated. </p>

</div>
</div>
<a id="aa1eafc28324bee46be7256f60e68952a" name="aa1eafc28324bee46be7256f60e68952a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1eafc28324bee46be7256f60e68952a">&#9670;&#160;</a></span>m_writeIdx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile unsigned Kit::Container::RingBufferBase::m_writeIdx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of the next item to be added to the ring. </p>
<p>This variable is only updated when a add operation is performed. In addition, the variable is atomically updated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Kit/Container/<a class="el" href="_ring_buffer_base_8h_source.html">RingBufferBase.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 30 2025 19:14:39 for Kit by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
