#!/usr/bin/python3
#=============================================================================
# Helper script (that does most of work) for generating FSM source code from
# Cadifra FSM diagrams
#
# This script runs the 'sinelaboreRT' Finite State Machine Code Generator
# utility.  The SinelaboreRT tool is proprietary tool, but the output of
# the code generator is NOT.  This script is also specific to parsing
# FSM diagramS generated by the Cadifra drawing tool (yet another 
# proprietary tool).  Yes - using non open source tools is straying from
# the pure faith - but both tools are very good and affordable - and the
# generated source code and diagram content is still 'free'.
#
# http://www.sinelabore.com/
# http://www.cadifra.com/
#
#=============================================================================

#
import sys   
import os
import subprocess
from tracemalloc import Trace
#
from nqbplib.docopt.docopt import docopt
from nqbplib import utils

# 
usage = """ 
genfsm - Generates source code from Cadifra FSM Diagrams (.cdd files)
===============================================================================
Usage: genfsm [options] <basename> <namespaces> [<sinelabore>...]
       genfsm [options] osal

Arguments:
  <basename>       Base name for the FSM.  The Cadifra diagram must have this
                   same file name.  All generated output files will have the 
                   <basename> as part of their file names. <basename> IS 
                   case sensitive!
      
  <namespaces>     The encapsulated namespace(s) for the generated files. The
                   Format is: 'Rte::Db::Record'
                   
  <sinelabore>     Optional arguments passed directly to the Sinelabore code
                   generator
  osal             Lists the support OSAL targets

Options:
  -d NEVENTS       When NEVENTS is greater then 0 code for an event queue is 
                   generated where NEVENTS is the size of the event queue. 
                   [Default: 0]
  -t OSAL          Specify which supported OSAL to use [Default: CPL]
  -h, --help       Display command help.
        
         
NOTES:
    o The environment variable SINELABORE_PATH is required/used to specify
      the location of the Sinelabore code generator JAR files (and it 
      supporting JAR files).
    o The script assumes that Graphviz's dot.exe is in the command path.
      GraphViz is used to generated the FSM diagram for Doxygen. See 
      http://www.graphviz.org
      
"""
#
import subprocess
import re
import sys


#-------------------------------------------------------------------------------
supported_osals = [ "CPL", "KIT" ]
osal            = None

copyright_header = None
cpl_copyright_header = """* This file is part of the Colony.Core Project.  The Colony.Core Project is an
* open source project with a BSD type of licensing agreement.  See the license
* agreement (license.txt) in the top/ directory or on the Internet at
* http://integerfox.com/colony.core/license.txt
*
* Copyright (c) 2014-2025  John T. Taylor
*
* Redistributions of the source code must retain the above copyright notice."""

kit_copyright_header = """ * Copyright Integer Fox Authors
 *
 * Distributed under the BSD 3 Clause License. See the license agreement at:
 * https://github.com/Integerfox/kit.core/blob/main/LICENSE
 *
 * Redistributions of the source code must retain the above copyright notice.
"""
copyright_headers = {
    "CPL": cpl_copyright_header,
    "KIT": kit_copyright_header
}
trace_include = {
    "CPL": "Cpl/System/Trace.h",
    "KIT": "Kit/System/Trace.h"
}
fatalerror_include = {
    "CPL": "Cpl/System/FatalError.h",
    "KIT": "Kit/System/FatalError.h"
}

ringbuffer_include = {
    "CPL": "Cpl/Container/RingBuffer.h",
    "KIT": "Kit/Container/RingBuffer.h"
}
ringbuffer_class = {
    "CPL": "Cpl::Container::RingBuffer",
    "KIT": "Kit::Container::RingBuffer"
}
fatalerror_logf = {
    "CPL": "Cpl::System::FatalError::logf(",
    "KIT": "Kit::System::FatalError::logf( Kit::System::Shutdown::eFSM_EVENT_OVERFLOW,"
}
trace_msg = {
    "CPL": "CPL_SYSTEM_TRACE_MSG( SECT_, (",
    "KIT": "KIT_SYSTEM_TRACE_MSG( SECT_,"
}
trace_msg_suffix = {
    "CPL": ")",
    "KIT": ""
}

#------------------------------------------------------------------------------
# Parse command line
def run( argv, copyright=None ):
    global copyright_header, osal

    # Process command line args...
    args  = docopt(usage, version="0.0.1", options_first=True )
    sargs = ' '.join( args['<sinelabore>'] )

    # Validate target OSAL
    osal = args['-t'].strip()
    if osal not in supported_osals:
        exit(f"ERROR: Unsupported OSAL ({osal}) specified. Use 'genfsm osal' to see supported OSALs.")

    # List supported OSALs
    if args['osal']:
        print("Supported OSALs:")
        for osal in supported_osals:
            print(f"{osal}")
        exit(0)

    # Check the environment variables
    sinpath = os.environ.get("SINELABORE_PATH")
    if ( sinpath == None ):
        exit( "ERROR: The SINELABORE_PATH environment variable is not set." )

    # Set copyright header (either explicit or based on OSAL)
    if ( copyright != None ):
        copyright_header = copyright
    else:
        copyright_header = copyright_headers[osal]

    # Convert namespace arg to list
    names = args['<namespaces>'].split('::')
    
    # Filenames
    fsmdiag = args['<basename>'] + ".cdd"
    base    = args['<basename>'] + "Context_" 
    evque   = args['<basename>'] + "EventQueue_" 
    fsm     = args['<basename>'] 
    cfg     = 'codegen.cfg'
      
    # Generated File names
    oldfsm      = fsm + '.h'
    oldfsmcpp   = fsm + '.cpp'
    oldevt      = fsm + '_ext.h'
    oldtrace    = fsm + '_trace.h'
    oldtracecpp = fsm + '_trace.cpp'
    oldtrace2   = fsm + '_trace.java'
    newfsm      = fsm + '_.h'
    newfsmcpp   = fsm + '_.cpp'
    newevt      = fsm + '_ext_.h'
    newtrace    = fsm + '_trace_.h'
    
    # Delete 'optional' old/previous files 
    utils.delete_file( evque + ".h" )
    utils.delete_file( evque + ".cpp" )
    
    # Create the config file for Sinelabore
    generatedCodegenConfig( cfg, base, names )
        
    # Build Sinelabore command
    if os.name == 'nt':
        cmd = f'java -cp {sinpath}/*; codegen.Main {sargs} -p CADIFRA -doxygen -o {fsm} -l cppx -Trace {fsmdiag}'
    else:
        cmd = f'java -cp {sinpath}/*.jar codegen.Main {sargs} -p CADIFRA -doxygen -o {fsm} -l cppx -Trace {fsmdiag}'
    cmd = utils.standardize_dir_sep( cmd )
  
    # Invoke Sinelabore command
    print(cmd)
    p = subprocess.Popen( cmd, shell=True )
    r = p.communicate()
    if ( p.returncode != 0 ):
        exit("ERROR: Sinelabore encounterd an error or failed to run." )
    
    # Clean-up config file (don't want it being checked into version control)
    os.remove( cfg )
    
    # Mangle the event names so that I can have many FSMs in the same namespace with the same event names
    eventList = get_events_names( oldevt )
    mangle_event_names( oldevt, eventList, fsm, ' ' )
    mangle_event_names( oldfsmcpp, eventList, fsm, '"', '0', '=' )
    mangle_event_names( oldtrace, eventList, fsm, '"' )
    cleanup_global_define( oldevt, fsm, names )

    # Generate Context/Base class
    actions, guards = getContextMethods( fsmdiag )
    generatedContextClass( base, names, getHeader(), actions, guards )
    
    # Generated event queuue class
    depth = args['-d'].strip()  
    if ( depth != '0' ):
        generateEventClass( evque, names, fsm, newfsm, depth )
        
    # Post process the generated file(s) to work better with Doxygen
    cleanup_fsm_for_doxygen( fsm + ".h", args['<namespaces>'] + "::" + fsm )
    cleanup_for_doxygen( oldtrace )
    cleanup_for_doxygen( oldevt )
      
    
    # Post process the generated file(s) 
    cleanup_trace( oldfsmcpp, names, fsm, oldfsm, oldtrace, newtrace, oldtracecpp )
    cleanup_includes( oldfsm,    names, oldfsm, newfsm, oldevt, newevt, base + '.h' )
    cleanup_includes( oldfsmcpp, names, oldfsm, newfsm, oldevt, newevt, base + '.h' )
    convert_member_to_class_methods_header( oldfsm, fsm )  
    convert_member_to_class_methods_cpp( oldfsmcpp, fsm )  

    # Housekeeping for naming convention
    utils.delete_file( newfsm )
    utils.delete_file( newfsmcpp )
    utils.delete_file( newevt )
    utils.delete_file( newtrace )
    utils.delete_file( oldtrace2 )      # remove unwanted JAVA file
    utils.delete_file( oldtracecpp )    # remove unused CPP file
    os.rename( oldfsm, newfsm )
    os.rename( oldfsmcpp, newfsmcpp ) 
    os.rename( oldevt, newevt ) 
    os.rename( oldtrace, newtrace ) 



#------------------------------------------------------------------------------
def get_events_names( ext_header_file ):
    found_start = False
    events      = []
    with open( ext_header_file ) as inf:
        for line in inf:
            line = line.lstrip()

            # Capture events
            if ( found_start ):
                if ( line.find("_NO_MSG") == -1 ):
                    event = line.strip().split('=')[0]
                    event = event.strip().split(',')[0]
                    events.append( event.strip() )

                # All events found -->can exit the function
                else:
                    break;

            # Find the start of the events                    
            if ( line.startswith( "enum" ) ):
                found_start = True

    # Return found events
    return events  

#
def mangle_event_names( file, events, prefix, pre_del1, pre_del2=None, pre_del3=None ):
    tmpfile       = file + ".tmp"
    found_indexes = False    
    with open( file ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:

                # Replace event names
                for e in events:
                    # Brute force approach to replacing whole event names (i.e. properly handle evStop & evStopped)
                    old_ev = pre_del1 + e
                    new_ev = pre_del1 + prefix + "_" + e
                    line   = line.replace(old_ev,new_ev,1)
                    if ( pre_del2 != None ):
                        old_ev = pre_del2 + e
                        new_ev = pre_del2 + prefix + "_" + e
                        line   = line.replace(old_ev,new_ev,1)
                        if ( pre_del3 != None ):
                            old_ev = pre_del3 + e
                            new_ev = pre_del3 + prefix + "_" + e
                            line   = line.replace(old_ev,new_ev,1)
                    
                # Fix event name indexes
                if ( found_indexes ):
                    line = fix_indexes( line, prefix );
                    found_indexes = False
                elif ( line.find( "const unsigned short evt_idx[]={" ) != -1 ):
                    found_indexes = True
                         
                outf.write( line )
    
    os.remove( file )
    os.rename( tmpfile, file )


# 
def fix_indexes( line, prefix ):
    line       = line.replace('};','').strip()
    k          = len(prefix) + 1
    offsets    = line.strip().split(",")
    idx        = 0
    newoffsets = []
    
    # Strip off potential trailing ',' (e.g. happens when there are no 'true' events)
    if ( offsets[len(offsets)-1] == '' ):
        del offsets[len(offsets)-1]

    for i in offsets:
        n      = int(i)
        newidx = n + idx * k
        idx   += 1
        newoffsets.append( str(newidx) )
        
    newline  = "        " + ','.join(newoffsets) + '};\n'
    return newline

#
def cleanup_for_doxygen( headerfile ):
    tmpfile = headerfile + ".tmp"
    skip_state = 0
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( line.startswith( "namespace") and skip_state == 0 ):
                    outf.write( "#ifndef DOXYGEN_WILL_SKIP_THIS\n\n");
                    outf.write( line );
                    skip_state += 1
                    continue
                if ( line.startswith( "#endif") and skip_state == 1):
                    outf.write( "#endif // !DOXYGEN_WILL_SKIP_THIS\n\n");
                    outf.write( line );
                    skip_state += 1
                    continue
                outf.write( line )

    os.remove( headerfile )
    os.rename( tmpfile, headerfile )
 
#
def cleanup_fsm_for_doxygen( headerfile, classname):
    tmpfile = headerfile + ".tmp"
    skip_state = 0
    brace_state = 0
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                # count curly braces (after the namespace)
                if skip_state > 0:
                    if '{' in line:
                        brace_state += 1
                    if '}' in line:
                        brace_state -= 1
                if ( line.startswith( "namespace") and skip_state == 0 ):
                    outf.write( line );
                    outf.write( "    /// Finite State Machine class\n");
                    skip_state += 1
                    continue
                if ( line.strip().startswith( "class") and skip_state == 1):
                    outf.write( line );
                    skip_state += 1
                    continue
                if ( line.strip().startswith( "{") and skip_state == 2):
                    outf.write( line );
                    outf.write( "    /// @cond \n");
                    skip_state += 1
                    continue

                if skip_state > 0 and brace_state == 0 and line.endswith("};\n"):
                    outf.write( "    /// @endcond \n");
                    outf.write( line );
                    continue
                if ( line.find( 'Here is the graph that shows the state machine' ) == -1 ):
                    outf.write( line )
                else:
                    outf.write( f"/** \\class {classname}\n\nHere is the graph that shows the state machine this class implements\n\n\\dot\n" )

    os.remove( headerfile )
    os.rename( tmpfile, headerfile )

#
def cleanup_global_define( headerfile, fsm_name, namespaces ):
    tmpfile = headerfile + ".tmp"
    skip_state = 0
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:

                if ( line.startswith( '#define InnermostStates ' )-1 ):
                    outf.write( line )
                else:
                    tokens = line.split()
                    outf.write( f'#define {flatten_namespaces(namespaces)}{fsm_name}_InnermostStates {tokens[2]};\n')
    
    os.remove( headerfile )
    os.rename( tmpfile, headerfile )
                     

#
def cleanup_includes( headerfile, namespaces, oldfsm, newfsm, oldevt, newevt, base ):
    tmpfile = headerfile + ".tmp"
    path    = path_namespaces( namespaces )
    
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( line.find( f'#include "{oldfsm}"' ) != -1):
                    outf.write( f'#include "{path}{newfsm}"\n' )
                elif ( line.find( f'#include "{oldevt}"' ) != -1) :
                    outf.write( f'#include "{path}{newevt}"\n' )
                elif ( line.find( f'#include "{base}"' ) != -1) :
                    outf.write( f'#include "{path}{base}"\n' )
                else:
                    outf.write( line )
    
    os.remove( headerfile )
    os.rename( tmpfile, headerfile )

#
def convert_member_to_class_methods_header( file, parent_class ):
    macroname = parent_class.upper()
    tmpfile  = file + ".tmp"
    with open( file ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( "const char* getNameByState(const unsigned short state) const" in line ):
                    line = line.replace("const char* getNameByState(const unsigned short state) const","static const char* getNameByState(const unsigned short state)" )
                if ( f"const char* getNameByEvent(const {macroname}_EVENT_T evt) const" in line ):
                    line = line.replace(f"const char* getNameByEvent(const {macroname}_EVENT_T evt) const", f"static const char* getNameByEvent(const {macroname}_EVENT_T evt)" )
                outf.write( line )
    os.remove( file )
    os.rename( tmpfile, file )

def convert_member_to_class_methods_cpp( file, parent_class ):
    macroname = parent_class.upper()
    tmpfile  = file + ".tmp"
    with open( file ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( f"const char* {parent_class}::getNameByState(const unsigned short state) const" in line ):
                    line = line.replace(f"const char* {parent_class}::getNameByState(const unsigned short state) const",f"const char* {parent_class}::getNameByState(const unsigned short state)" )
                if ( f"const char* {parent_class}::getNameByEvent(const {macroname}_EVENT_T evt) const" in line ):
                    line = line.replace(f"const char* {parent_class}::getNameByEvent(const {macroname}_EVENT_T evt) const", f"const char* {parent_class}::getNameByEvent(const {macroname}_EVENT_T evt)" )
                outf.write( line )
    os.remove( file )
    os.rename( tmpfile, file )
                
      
#      
def cleanup_trace( cppfile, namespaces, base, oldfsm, old_trace_headerfile, new_trace_headerfile, oldtracecpp ):
    # Add xx_trace_.h include to xxx_.cpp
    tmpfile  = cppfile + ".tmp"
    path     = path_namespaces( namespaces )
    newstate = 'stateVars = stateVarsCopy;'
    newcount = 0
    
    # Update the state machine .cpp file with Tracing tweaks
    prev_line = ''
    with open( cppfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                # Remove Trace call from the initialize method
                if ( f"{base}TraceEvent(" in line and f"{base}::initialize()" in prev_line ):
                    pass
                
                # Keep the current line...
                else:
                    outf.write( line )
                    if ( line.find( f'#include "{oldfsm}"' ) != -1):
                        outf.write( f'#include "{path}{new_trace_headerfile}"\n' )


                    # Add trace for transitioned TO state (but skip the initialize() method because trace + statically created instance DON'T mix)    
                    elif ( line.find( newstate ) != -1 ):
                        newcount += 1
                        if ( newcount > 1 ):
                            outf.write( f'    {trace_msg[osal]} "New State=%s", getNameByState(getInnermostActiveState()) {trace_msg_suffix[osal]});\n' )
                prev_line = line
                
    os.remove( cppfile )
    os.rename( tmpfile, cppfile )

    # Get event array from trace.cpp
    events = ''
    found  = False
    with open( oldtracecpp, "r") as inf:  
        for line in inf:
            if ( line.find("const") != -1 or found == True ):
                events = events + line
                found  = True
                if ( line.find(';') != -1 ):
                    found = False


    # add CPL trace hooks
    tmpfile  = old_trace_headerfile + ".tmp"
    trace_fn = 'TraceEvent('
    
    added_include = False
    with open( old_trace_headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( line.find( '#define' ) != -1 and added_include == False ):
                    added_include = True
                    outf.write( line )
                    outf.write( f'\n' )
                    outf.write( f'#include "{trace_include[osal]}"\n' )
                    outf.write( f'\n' )
                    outf.write( f'/// Trace Section\n' )
                    outf.write( f'#define SECT_ "{"::".join(namespaces)}::{base}"\n' )
                    outf.write( f'\n' )
                elif ( line.find( trace_fn ) != -1 ):
                    outf.write( f'#define {base}TraceEvent(a) {trace_msg[osal]} "  Old State=%s, Event=%s", getNameByState(getInnermostActiveState()), {base}TraceEvents[a] {trace_msg_suffix[osal]});\n' )
                    outf.write( f'\n')        
                    outf.write( events )
                else:
                    outf.write( line )


    os.remove( old_trace_headerfile )
    os.rename( tmpfile, old_trace_headerfile )
     
     
     
#------------------------------------------------------------------------------
def getContextMethods( fname ):
    actions = []
    guards  = []
    with open(fname) as f:
        for line in f:
            guard_matches = re.findall(r'[^a-zA-Z0-9_]([a-zA-Z0-9]+\(\))(?!\;)',line)
            a = re.search(r'[a-zA-Z0-9]+\(\)\;', line)
            if ( guard_matches != None ):
                guards.extend( guard_matches )
            if ( a != None ):
                actions.append( a.group(0).split(';')[0] )
    
    # Remove any duplicates from the grep'd methods
    return sorted(list(set(actions))), sorted(list(set(guards)))

def path_namespaces( namespaces ):
    flat = ''
    for n in namespaces:
        flat += n + "/"

    return flat

def flatten_namespaces( namespaces ):
    flat = ""
    for n in namespaces:
        flat += n + "_"

    return flat

def nested_namespaces( namespaces ):
    nest = ""
    for n in namespaces:
        nest += f"namespace {n} {{ "

    return nest
    
def end_nested_namespaces( namespaces ):
    nest = ""
    for n in namespaces:
        nest += "}"
    nest += "  // end namespace(s)"
    return nest

def cfg_namespaces( namespaces ):
    nest  = "*"
    for n in namespaces:
        if ( nest == "*" ):
            nest = n + " " 
        else:
            nest += f"{{ namespace {n} "

    return nest
    
def end_cfg_namespaces( namespaces ):
    nest  = ""
    count = len(namespaces)
    if ( count > 1 ):
        for n in range(1,count):
            nest += "};"
    
    return nest
    

def generatedContextClass( class_name, namespaces,  header, actions, guards ):
    fname = class_name + '.h'
    flat  = flatten_namespaces(namespaces)
    with open(fname,"w") as f:
        f.write( f"#ifndef {flat}{class_name}x_h_\n" )
        f.write( f"#define {flat}{class_name}x_h_\n" )
        f.write( header )
        f.write( f"\n\n/* This file is auto-generated DO NOT MANUALLY EDIT this file! */\n\n" )
        f.write( f"\n" )
        f.write( f"///\n" )
        f.write( f"{nested_namespaces(namespaces)}\n" )
        f.write( f"\n\n" )
        f.write( f"/// Context (aka actions/guards) for my Finite State Machine\n" )
        f.write( f"class {class_name}\n" )
        f.write( f"{{\n" )
        f.write( f"public:\n" )
        for a in actions:
            f.write( f"    /// Action\n" )
            f.write( f"    virtual void {a} noexcept = 0;\n" )
            f.write( f"\n" )
        f.write( f"\n" )
        f.write( f"public:\n" )
        for g in guards:
            f.write( f"    /// Guard\n" )
            f.write( f"    virtual bool {g} noexcept = 0;\n" )
            f.write( f"\n" )
        f.write( f"\n" )
        f.write( f"public:\n" )
        f.write( f"    /// Virtual Destructor\n" )
        f.write( f"    virtual ~{class_name}(){{}}\n" )
        f.write( f"\n" )
        f.write( f"}};\n" )
        f.write( f"\n" )
        f.write( f"{end_nested_namespaces(namespaces)}\n" )
        f.write( f"#endif /// end header latch\n" )
         
    
def generateEventClass( class_name, namespaces,  parent_class, parent_header, depth ):
    fname     = class_name + '.h'
    flat      = flatten_namespaces(namespaces)
    path      = path_namespaces( namespaces )
    macroname = parent_class.upper()
    
    with open(fname,"w") as f:
        f.write( f"#ifndef {flat}{class_name}x_h_\n" )
        f.write( f"#define {flat}{class_name}x_h_\n" )
        f.write( getHeader() )
        f.write( "\n\n/* This file is auto-generated DO NOT MANUALLY EDIT this file! */\n\n" )
        f.write( "\n" )
        f.write( f'#include "{path}{parent_header}"\n' )
        f.write( f'#include "{ringbuffer_include[osal]}"\n' )
        f.write( f"\n\n" )
        f.write( f"///\n" )
        f.write( f"{nested_namespaces(namespaces)}\n" )
        f.write( f"\n\n" )
        f.write( f"/// Event Queue for FSM events.\n" )
        if ( osal == "CPL" ):
            f.write( f"class {class_name}: public {parent_class}, public {ringbuffer_class[osal]}<{macroname}_EVENT_T>\n" )
        else:
            f.write( f"class {class_name}: public {parent_class}, public {ringbuffer_class[osal]}<{macroname}_EVENT_T,{depth}>\n" )
        f.write( f"{{\n" )
        f.write( f"public:\n" )
        f.write( f"    /// Define callback function that is called when an event has completed\n" )
        f.write( f"    typedef void ( *EventCompletedCbFunc_T )( {macroname}_EVENT_T proceessedMsg );\n" )
        f.write( f"\n" )
        f.write( f"protected:\n" )
        f.write( f"    /// Optional Callback function for event-completed (typically used for unit testing purposes)\n" )
        f.write( f"    EventCompletedCbFunc_T  m_eventCompletedCallback;\n" )
        f.write( f"\n" )
        if ( osal == "CPL" ):
            f.write( f"    /// Memory for Event queue\n" )
            f.write( f"    {macroname}_EVENT_T m_eventQueMemory[{depth}];\n" )
            f.write( f"\n")
        f.write( f"    /// Flag for tracking re-entrant events\n" )
        f.write( f"    bool m_processingFsmEvent;\n" )
        f.write( f"\n")
        f.write( f"public:\n" )
        f.write( f"    /// Constructor\n" )
        f.write( f"    {class_name}( EventCompletedCbFunc_T eventCompletedCallback = nullptr );\n" )
        f.write( f"\n")
        f.write( f"public:\n" )
        f.write( f"    /// This method properly queues and process event messages\n" )
        f.write( f"    virtual void generateEvent( {macroname}_EVENT_T msg );\n" )
        f.write( f"}};\n" )
        f.write( f"\n" )
        f.write( f"{end_nested_namespaces(namespaces)}\n" )
        f.write( f"#endif /// end header latch\n" )

    fname = class_name + '.cpp'
    flat  = flatten_namespaces(namespaces)
    with open(fname,"w") as f:
        f.write( getHeader() )
        f.write( f"\n\n/* This file is auto-generated DO NOT MANUALLY EDIT this file! */\n\n" )
        f.write( f"\n" )
        f.write( f'#include "{class_name}.h"\n' )
        f.write( f'#include "{fatalerror_include[osal]}"\n' )
        f.write( f'#include "{trace_include[osal]}"\n' )
        f.write( f"\n" )
        f.write( f'#define SECT_ "{'::'.join(namespaces)}::{parent_class}"\n' )
        f.write( f"\n" )
        f.write( f"///\n" )
        f.write( f"{nested_namespaces(namespaces)}\n" )
        f.write( f"\n\n" )
        f.write( f"{class_name}::{class_name}( EventCompletedCbFunc_T eventCompletedCallback )\n" )
        if ( osal == "CPL" ):
            f.write( f": {ringbuffer_class[osal]}<{macroname}_EVENT_T>( {depth}, m_eventQueMemory )\n" )
            f.write( f", m_eventCompletedCallback( eventCompletedCallback )\n" )
        else:
            f.write( f": m_eventCompletedCallback( eventCompletedCallback )\n" )
        f.write( f", m_processingFsmEvent(false)\n" )
        f.write( f"    {{\n" )
        f.write( f"    }}\n" )
        f.write( f"\n\n" )
        f.write( f"void {class_name}::generateEvent( {macroname}_EVENT_T msg )\n" )
        f.write( f"    {{\n" )
        f.write( f"    // Queue my event\n" )
        f.write( f"    if ( !add( msg ) )\n" )
        f.write( f"        {{\n" )
        f.write( f'        {fatalerror_logf[osal]} "{'::'.join(namespaces)}::{class_name}: - Buffer Overflow!" );\n' )
        f.write( f"        }}\n" )
        f.write( f"\n" )
        f.write( f"    // Protect against in-thread 'feedback loops' that can potentially generate events\n" )
        f.write( f"    if ( !m_processingFsmEvent )\n" )
        f.write( f"        {{\n" )
        f.write( f"        m_processingFsmEvent = true;\n" )
        f.write( f"        while( remove( msg ) )\n" )
        f.write( f"            {{\n" )
        f.write( f'            {trace_msg[osal]}"EVENT:= %s, current state=%s ...", getNameByEvent(msg), getNameByState(getInnermostActiveState()){trace_msg_suffix[osal]} );\n' )
        f.write( f"            if ( processEvent(msg) == 0 )\n" )
        f.write( f"                {{\n" )
        f.write( f'                {trace_msg[osal]}"  IGNORED: end state=%s", getNameByState(getInnermostActiveState()){trace_msg_suffix[osal]} );\n' )
        f.write( f"                }}\n" )
        f.write( f"            else\n" )
        f.write( f"                {{\n" )
        f.write( f'                {trace_msg[osal]}"  Completed: end state=%s", getNameByState(getInnermostActiveState()){trace_msg_suffix[osal]} );\n' )
        f.write( f"                }}\n" )
        f.write( f"\n" )
        f.write( f"            // Provide 'hook' for event-processing-completed\n" )
        f.write( f'            if ( m_eventCompletedCallback )\n' )
        f.write( f'                {{\n' )
        f.write( f'                (m_eventCompletedCallback) ( msg );\n' )
        f.write( f'                }}\n' )
        f.write( f"            }}\n" )
        f.write( f"\n" )
        f.write( f"        m_processingFsmEvent = false;\n" )
        f.write( f"        }}\n" )
        f.write( f"    }}\n" )
        f.write( f"\n" )
        f.write( f"{end_nested_namespaces(namespaces)}\n" )

#-------------------------------------------------------------------------------        
#
def generatedCodegenConfig( fname, base, names ):
    cfg = '''# Output configuration options for the given language. Pipe them into a file for further use!
#
#Allows to define naming conventions for events
PrefixEvents=
#
#Allows to define naming conventions for simple states
PrefixSimpleStates=
#
#Allows to define naming conventions for composite states
PrefixCompositeStates=
#
#Allows to define naming conventions for choice states
PrefixChoice=

#
#Path to 'dot.exe'.
#DotPath="C:\\Program Files\\Graphviz2.22\\bin\\dot.exe"
#DotPath=/usr/local/bin/dot
DotPath=
#
#Port the graphical statediagram.simulator listens for event strings. 
UdpPort=4445
#
#Options 'yes' and 'no' are possible. If set to 'yes' only hot transitions are shown
ShowOnlyHotTransitions=no
#
#It is possible to limit the length of the event text. This keeps the image compact.
NumberOfTransitionChars=32
#
#If set to 'yes' only correct models can be saved.
SaveCheckedOnly=yes
#
#If set to 'yes' action code is displayed in the state diagram of the integrated statediagram.editor.
DisplayEntryExitDoCode=yes
#
#Limit action code in the integrated statediagram.editor to the given number of chars.
NumberOfEntryExitDoCodeChars=32
#
#

#Defines the text each generated file starts with.
Copyright=$$HEADER$$
#
#Defines if real tabs or spaces are used for indentation.
Realtab=no
#
#If realtab is 'no' this key defines how many spaces to use per tab
Tabsize=4
#
#Some systems can use special compiler keywords to place the debug strings in program memory or a specifc segment
TypeOfDbgString=const char
#
#If set to 'no' the data and time info is supressed in each file header
IncludeDateFileHeaders=no

#
#Optional namespace used in the generated C#, Java and C++ file.
Namespace=$$NAMESPACE_START$$
NamespaceEnd=$$NAMESPACE_END$$
#
#Define a base classes for the generated machine class.
BaseClassMachine=$$BASE$$

#
#Define an optional base classes for the generated state classes.
BaseClassStates=
#
#If set to yes virtual create methods are gen- erated in the factory class.
CreateFactoryMethodsVirtual=No
#
#If set to yes all state classes are generated into a single cpp/h file.
CreateOneCppStateHeaderFileOnly=Yes
#
#If set to 'yes' a destructor for the state mchine class is generated. If set to 'virtual' a virtual destructor is generated. If set to 'no' no destructor is generated.
StateMachineClassHasDestructor=no
#
#If set to 'yes' separte state classes are used. Otherwise action code is completely inlined into the state machine code
SeparateStateClasses=no
#
ReturnEventProcessed=yes

'''
    # Replace tokens
    cfg = cfg.replace( "$$BASE$$", base )
    cfg = cfg.replace( "$$HEADER$$", getHeaderCfg() )
    cfg = cfg.replace( "$$NAMESPACE_START$$", cfg_namespaces(names) )
    cfg = cfg.replace( "$$NAMESPACE_END$$",   end_cfg_namespaces(names) )
    
    # create file
    with open(fname,"w") as f:
        f.write( cfg )

    

#------------------------------------------------------------------------------
def getHeader():
    return  '/*-----------------------------------------------------------------------------\n' + copyright_header + '\n*----------------------------------------------------------------------------*/\n/** @file */\n\n'

def getHeaderCfg():
    text = copyright_header.replace('\n', r'\n')
    return r'/*-----------------------------------------------------------------------------\n' + text + r'\n*----------------------------------------------------------------------------*/\n/** @file */\n\n'

